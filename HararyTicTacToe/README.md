
## Harary Generalized Tic-Tac-Toe

Various programs for working with Harary tic-tac-toe,
a.k.a. "animal tic-tac-toe," and tic-tac-toe in general.

### Harary tic-tac-toe

`make-oracle.cpp` is an interactive program for generating an oracle
(that is, an exhaustive dictionary of best moves) for a 2D tic-tac-toe-like
game. Compile it with `-DB=n` to make the board n×n. It will repeatedly
show you board positions and ask you to input X's best move for each one.
This will be super tedious for any grid size larger than 3×3! You might be
better off editing a dictionary by hand!

`make-oracle.cpp` doesn't know what shape you're trying to make, so it will
also ask you after each move whether you've won yet.

`play-against-oracle.cpp` is an interactive program for playing against
the dictionary generated by `make-oracle.cpp`. Compile it with `-DB=n` to
make the board n×n. Again, it has no idea when it's won, except that its
dictionary will eventually run out of responses.

### Oren Patashnik's 4x4x4 winning strategy

Oren Patashnik, ["Qubic: 4x4x4 Tic-Tac-Toe"](https://ranger.uta.edu/~weems/NOTES6319/PAPERSONE/patashnik.pdf) (1980),
presents a dictionary-based solution for 4x4x4 tic-tac-toe
(four-in-a-row on a 4x4x4 cube). The dictionary is only partial;
it relies on a fair bit of "smarts" from the computer player not
only to play obvious 4-in-a-rows and block O's threats, but even
to tree-search for "forced sequences" as described in Patashnik's
paper. A "dumb" player can play Qubic using Patashnik's dictionary
only up to a point, at which point it'll have to say "obviously
I can win from here; trust me bro."

`qubic.dictionary` is Oren Patashnik's original dictionary from 1976–1980.

`convert-qubic-dictionary.py` is a Python program that converts
Patashnik's notation into my own notation, line for line.

`simple-compress-dictionary.py` is a greedy algorithm to compress
a dictionary in my notation. Patashnik's dictionary compresses
down to about 900 lines (more or perhaps fewer, depending on how
the lines are ordered, because of how the greedy algorithm works).

(The resulting dictionary is in approximately the right format to be
consumed by `play-against-oracle.cpp`, except that `play-against-oracle.cpp`
cannot handle 3D: it can't display the board properly but more importantly
it doesn't know all the symmetries of the cube so it can't look up moves
in the dictionary properly.)
